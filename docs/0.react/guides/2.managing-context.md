---
title: Understanding Async Context and useHead()
description: Manage head tags with useHead() in React across async operations, component lifecycles, and server-side rendering.
navigation:
  title: 'Async Context'
---

## Understanding React Context

The `useHead()`{lang="Ts"} hook uses React's Context API under the hood to access the Unhead instance:

```ts
import { UnheadContext } from '@unhead/react'
import { useContext } from 'react'

function useHead(input) {
  const head = useContext(UnheadContext)
  head.push(input)
}
```

## Handling Async Updates

Here are the key patterns for managing async head updates:

### Using `useEffect()`{lang="ts"}

The most basic way to handle async updates is with `useEffect`:

```tsx
import { useHead } from '@unhead/react'
import { useEffect, useState } from 'react'

function MyComponent() {
  const [title, setTitle] = useState('Loading...')

  useEffect(() => {
    async function loadData() {
      const data = await fetchData()
      setTitle(data.title)
    }
    loadData()
  }, [])

  // Head automatically updates when title changes
  useHead({
    title
  })

  return <div>{title}</div>
}
```

### Using State for Complex Head Data

For more complex head configurations, manage your state with objects:

```ts
import { useHead } from '@unhead/react'
import { useEffect, useState } from 'react'

function PageHead() {
  const [pageData, setPageData] = useState({
    title: 'Loading...',
    description: '',
    image: '/placeholder.jpg'
  })

  useHead({
    title: pageData.title,
    meta: [
      {
        name: 'description',
        content: pageData.description
      },
      {
        property: 'og:image',
        content: pageData.image
      }
    ]
  })

  useEffect(() => {
    async function loadPage(id) {
      const data = await fetchPage(id)
      setPageData(data)
    }
    loadPage('home')
  }, [])

  return null
}
```

### Using React Query

For better async state management, consider using [React Query](https://tanstack.com/query/latest):

```ts
import { useQuery } from '@tanstack/react-query'
import { useHead } from '@unhead/react'

function PageHead({ id }) {
  const { data = { title: 'Loading...', description: '' } } = useQuery({
    queryKey: ['page', id],
    queryFn: () => fetchPage(id)
  })

  useHead({
    title: data.title,
    meta: [
      {
        name: 'description',
        content: data.description
      }
    ]
  })

  return null
}
```

### Using Redux

For global state management, you can combine useHead with Redux:

```ts
import { useHead } from '@unhead/react'
import { useSelector } from 'react-redux'

function PageHead() {
  const { title, description } = useSelector(state => state.page)

  useHead({
    title,
    meta: [
      {
        name: 'description',
        content: description
      }
    ]
  })

  return null
}
```

## Performance Tips

1. Use `useMemo` for complex head configurations
2. Consider code-splitting head components for lazy loading
3. Debounce rapid head updates using `useCallback`

## Next.js Integration

When using Next.js, you get additional benefits for head management through the App Router:

```tsx [app/layout.tsx]
import { useHead } from '@unhead/react'

export default function RootLayout() {
  useHead({
    titleTemplate: '%s | My Site'
  })

  return <html>...</html>
}
```

## Learn More

- [React Query Data Management](https://tanstack.com/query/latest/docs/react/overview)
- [React Context Deep Dive](https://react.dev/learn/passing-data-deeply-with-context)
- [Next.js Metadata API](https://nextjs.org/docs/app/api-reference/functions/generate-metadata)
