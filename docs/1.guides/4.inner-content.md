---
title: Inline Style & Script Tags
description: Learn how to safely add inline styles and scripts using Unhead's inner content features.
---

## Introduction

The `<style>`{lang="html"}, `<script>`{lang="html"} and `<noscript>`{lang="html"} tags are unique in HTML as they can contain inner content that directly affects how your page behaves and appears. Unhead provides powerful utilities to manage this inner content safely and efficiently.

Unlike most other HTML tags which primarily use attributes, these special tags rely on their content to function. With Unhead, you can manipulate this content programmatically while benefiting from the library's deduplication and optimization features.

## Inner Content

When working with the inner content of a tag, you can set the inner content using the `textContent`{lang="bash"} or `innerHTML`{lang="bash"} properties. These properties control what appears between the opening and closing tags.

The choice between the two depends on your specific needs:

- `textContent`{lang="bash"}: Treats the content as plain text, escaping any HTML characters
- `innerHTML`{lang="bash"}: Interprets the content as HTML, which allows for structured content but requires security considerations

```ts
useHead({
  script: [
    {
      innerHTML: 'window.analytics = window.analytics || []',
    },
  ],
  style: [
    {
      textContent: 'body { background: salmon; color: cyan; }',
    },
  ]
})
```

### Safely using `innerHTML`

Setting the inner content using `textContent` is the safest way if you are not sure about the content, however in some instances you will need to use `innerHTML`. This is especially true when working with rich content or third-party scripts that require HTML structure.

::caution
When using `innerHTML` the content will not be sanitised. Make sure you sanitise user input if providing it with this property. Unsanitized content can lead to cross-site scripting (XSS) vulnerabilities that may compromise your application's security.
::

If you must use `innerHTML` with external content, consider implementing a sanitization library like DOMPurify or using a framework-specific sanitization utility to filter out potentially dangerous content.

```ts
const someUserScript = await loadMyUserScript()
useHead({
  script: [
    {
      // ‚ùå Eek! This is dangerous!
      innerHTML: someUserScript
    },
  ],
})
```

## Shorthand Syntax

For ease of use, you can provide a string as the array entry and Unhead will choose the correct property to set. This shorthand syntax makes your code cleaner and more concise.

Behind the scenes, Unhead will automatically determine whether to use `textContent` or `innerHTML` based on the tag type. For `<style>` tags, it applies the content as `textContent`, while for `<script>` and `<noscript>` it typically uses the appropriate property based on content.

```ts
useHead({
  script: [
    'window.analytics = window.analytics || []',
  ],
  style: [
    'body { background: salmon; color: cyan; }',
  ]
})
```

## Best Practices

When working with inner content in tags, follow these best practices:

::tip
Always prefer `textContent` over `innerHTML` when possible for security reasons.
::

1. **Security First**: Always sanitize any user-generated content before using it with `innerHTML`
2. **Performance**: Minimize inline styles and scripts as they can block rendering
3. **Specificity**: Be aware that inline styles have high specificity which may override other styles
4. **Organization**: For larger styles or scripts, consider using external files instead of inline content

::note
For critical CSS that needs to be loaded immediately, inline styles can improve performance by avoiding an additional request.
::

## Related Resources

- [useScript API](/api/use-script) - For more advanced script management
- [useSeoMeta API](/api/use-seo-meta) - For managing SEO-related meta tags
- [Class Attributes](/guides/class-attr) - Managing HTML class attributes
